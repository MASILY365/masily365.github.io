{"pages":[{"title":"关于网站","text":"记录与分享同行","link":"/about/index.html"}],"posts":[{"title":"Centos 中安装使用 Docker 及 Docker Compose","text":"Centos 安装使用 Docker 和 Docker Compose 的简单步骤 Docker 安装使用安装 官网文档链接：https://docs.docker.com/engine/install/centos/ 1.移除旧版本12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.安装yum-utils包1sudo yum install -y yum-utils 3.配置镜像仓库123456789# 默认配置sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 配置阿里云sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4.安装docker-ce1sudo yum install docker-ce docker-ce-cli containerd.io 5.启动docker12sudo systemctl enable dockersudo systemctl start docker 6.验证安装1sudo docker run hello-world 更新1.更新 Docker CE1sudo yum update docker-ce 卸载1.卸载 Docker CE1sudo yum remove docker-ce 2.删除本地文件 注意，docker 的本地文件，包括镜像(images), 容器(containers), 存储卷(volumes)等，都需要手工删除。默认目录存储在 /var/lib/docker。 1sudo rm -rf /var/lib/docker Docker Compose 安装使用 官网相关文档：https://docs.docker.com/compose/install/ 1.安装1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose If you have problems installing with curl, see Alternative Install Options tab above 2.文件夹授权1sudo chmod +x /usr/local/bin/docker-compose Note: If the command docker-compose fails after installation, check your path. You can also create a symbolic link to /usr/bin or any other directory in your path. 3.验证安装1docker-compose --version","link":"/centos-docker/"},{"title":"工作流引擎 flowable 在 Spring Boot 中使用","text":"工作流引擎用于流程控制，常出现在 OA 系统中。常见的工作流引擎有 Activity、Flowable 等。 本文需对 Flowable 和 BPMN2.0 相关概念有一个大致的了解，参考 Getting Started · Flowable Open Source Documentation 项目搭建 创建 Spring Boot 项目 work-flow 添加 spring-boot-starter-data-jpa、spring-boot-starter-web、mysql-connector-java、flowable-spring-boot-starter 等基础依赖 配置 application.yml 123456789spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 url: jdbc:mysql://127.0.0.1:3306/work_flow?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;nullCatalogMeansCurrent=true jpa: generate-ddl: true 注：启动项目出现 Table 'xxx' doesn't exist 错误。 在数据配置 url 后加入 &amp;nullCatalogMeansCurrent=true 原因 flowable启动的时候会遍历当前数据库连接下的所有库表进行查询（因为使用的是root用户登录）如果其他库，有flowable相关表的话，就会被判定为不缺少表。默认情况下，就不会进行表更新操作。但是在实例化对象的时候，又无法查到相关数据，所以会在启动时报错。 项目测试Flowable UI 应用我们直接从官网下载 下载完成后解压 运行 java -jar flowable-ui.war 启动 访问 http://localhost:8080/flowable-ui","link":"/flowable-spring-boot/"},{"title":"Hexo 搭建自己的博客","text":"Hexo 是一个快速、简洁且高效的博客框架，可以一键部署到 GitHub Page 等平台。 本文主要记录通过 Hexo 并配置高颜值 icarus 主题搭建个人博客的过程。 Hexo 优点： 速度快、支持 Markdown、部署方便、可扩展性好等。 项目创建 准备 Node 安装：建议安装 NVM，可切换 node 版本（V14+）。Node 和 NVM 的安装和使用后续更新⌛。GitHub 账号。 创建 hexo 项目 12345678910# 安装 hexo cli 工具npm install hexo-cli -g# 在一个目录下初始化项目hexo init blog# 进入项目cd blog# 安装依赖npm install# 启动服务hexo server 添加 icarus 主题 12npm install hexo-theme-icarushexo config theme icarus 安装完成后启动程序，查看主题是否安装成功 1hexo serve 注： 如果出现如图错误 执行命令 npm install --save bulma-stylus@0.8.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 重启 hexo serve 修改部署配置 添加 hexo 部署 GitHub 依赖 npm install hexo-deployer-git 在 _config.yml 中添加部署配置 1234deploy: type: git repo: repo address branch: main 最后blog源码上传至 GitHub Github Page 配置 新建 &lt;username&gt;.github.io 仓库 在 &lt;username&gt;.github.io -&gt; setting -&gt; Pages 中 source 中选择 root 点击 save 访问 &lt;username&gt;.github.io 测试 配置 GitHub ActionGitHub Actions 可以很方便实现 CI/CD 工作流。 用途： 自动化测试、打包、部署等操作。 支持容器： Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以像在本地电脑中进行一系列操作。 本文说明： 利用 Github Actions 实现自动部署 hexo 到 Github Pages。 生成部署密钥 12# 一路回车ssh-keygen -f github-deploy-key 文件路径：当前目录下会有 github-deploy-key 和 github-deploy-key.pub 两个文件 配置部署密钥 私钥（github-deploy-key）：存放在博客源代码仓库 复制 github-deploy-key 文件内容，在 blog 仓库 Settings -&gt; Secrets-&gt; Action -&gt; Add a new secret 页面上添加。 在 Name 输入框填写 HEXO_DEPLOY_PRI。 在 Value 输入框填写 github-deploy-key 文件内容 公钥（github-deploy-key.pub）：存在账户公钥中。 复制 github-deploy-key.pub 文件内容，在 &lt;username&gt;.github.io 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。 在 Title 输入框填写 HEXO_DEPLOY_PUB。 在 Key 输入框填写 github-deploy-key.pub 文件内容。 勾选 Allow write access 选项。 编写 GitHub Actions 在 blog 仓库根目录下创建 .github/workflows/deploy.yml 文件，目录结构如下。 1234blog (repository)└── .github └── workflows └── deploy.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Action 名称name: HEXO CI# 触发条件on: # push 时触发 Action（即：当当前项目的 main 分支有 push 操作时触发此 Action） push: # 所属分支 branches: - main# 设置的环境变量（后续执行步骤时所用）env: # GitHub用户名 GIT_USER: MASILY365 # GitHub邮箱 GIT_EMAIL: masily365@gmail.com# 任务列表jobs: build: # 任务名称 name: Build on node ${{ matrix.node_version }} and ${{ matrix.os }} # 所需容器 runs-on: ubuntu-latest # 策略 strategy: matrix: os: [ ubuntu-latest ] node_version: [ 14.x ] # 步骤数组 # name步骤名，编译时会会以 LOG 形式输出 # with 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。 steps: # 此步骤：调用 actions/checkout@v2 可以实现 Checkout 一个 git 仓库到容器。 # 当前仓库到本地，with.repo 不填写默认为当前仓库，否则 with.repo: ${{ github.repository }} # with.ref: master,with.path: themes/ico 分别为版本和存放目录 - name: Checkout # 所要调用的 Action，可以到 https://github.com/actions 查看更多。 uses: actions/checkout@v2 # 此步骤：安装 Node.js 版本 v14 到容器中，with.node-version 可以指定 Node.js 版本。 - name: Use Node.js ${{ matrix.node_version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node_version }} # 此步骤：安装依赖 - name: Install dependencies run: | npm i -g hexo-cli npm i # 此步骤：设置部署的key - name: Setup Deploy Private Key env: HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}} run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # 此步骤：设置 git 配置 - name: Setup Git Infomation run: | git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL # 此步骤：部署 - name: Deploy hexo run: | hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 小结 hexo 相关命令 1234567891011# 添加关于hexo new page about# 添加分类hexo new page categories# 添加标签hexo new page tags# 新建文章hexo new 文章标题 注： deploy.yml中一些变量需换成自己环境数据","link":"/hexo-create-blog/"},{"title":"jetbrains 开发工具的激活使用","text":"使用文档详见出处 相关链接","link":"/idea-crack/"},{"title":"idea 开发工具热部署","text":"所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。 在 idea 开发过程中时常修改程序代码，每次修改后需要重启服务以生效修改内容。本文主要讲述 Spring Boot 通过配置和 JRebel 工具实现热部署。 Jrebel 热部署插件安装设置 &gt; 插件 &gt; Marketplace &gt; JRebel(JRebel and XRebel) &gt; 安装 &gt; 重启 IDE 配置启动IDEA 点击左侧栏的 JRebel 选中需要热部署的项目 IDEA 点击右上方的 JRebel 启动/debug启动项目 完成 JRebel 热部署 Spring Boot 热部署maven依赖及配置 添加依赖 1234567&lt;!--热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt; maven 配置 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork:如果没有该项配置,整个devtools不会起作用--&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; IDEA 配置 配置 compile ，勾选 Build project automatically 如图 Ctrl+shift+Alt+/ 选择 Register 勾选 compiler.automake.allow.when.app.running 如图 完成 Spring Boot 热部署。 小结在 spring boot 中也可以不用进行配置，直接使用 Jrebel 工具进行热部署。","link":"/idea-hot-deploy/"},{"title":"Java SPI 机制","text":"SPI 为 Service provider Interface 的缩写，译为服务提供发现接口。是JDK内置的一种服务提供发现机制。 SPI 是一种动态替换发现的机制，比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。 开始 项目描述：首先我们创建一个搜索的 SPI 接口（Search），文件搜索（FileSearch）和数据库搜索（DatabaseSearch）实现这个 SPI 接口，在配置文件中可动态添加减少搜索接口的实现类。 创建 SPI 接口 创建搜索 SPI 接口（Search） 12345678910package com.masily.spi;/** * @author masily * @since 2022/3/14 13:27 */public interface Search { void doc(String keyword);} SPI 实现 创建实现 SPI 接口类 文件搜索实现类（FileSearch） 12345678910111213141516package com.masily.spi.impl;import com.masily.spi.Search;/** * @author masily * @since 2022/3/14 13:28 */public class FileSearch implements Search { @Override public void doc(String keyword) { System.out.println(&quot;文件查询：&quot; + keyword); }} 数据搜索实现类（DatabaseSearch） 12345678910111213141516package com.masily.spi.impl;import com.masily.spi.Search;/** * @author masily * @since 2022/3/14 13:28 */public class DatabaseSearch implements Search { @Override public void doc(String keyword) { System.out.println(&quot;数据库查询：&quot; + keyword); }} 添加配置 在资源文件 resource 下新建 META-INF/services 文件夹 在 META-INF/services 文件夹下新建 SPI 接口引用路径 com.masily.spi.Search 的文件（如下图） 在 com.masily.spi.Search 文件中增减 SPI 具体实现类的应用路径（如下图） 测试 使用 ServiceLoader 的 load 方法加载 SPI 接口类（Search） 12345678910111213141516171819202122232425262728293031package com.masily;import com.masily.spi.Search;import java.util.Iterator;import java.util.ServiceLoader;/** * @author masily * @since 2022/3/14 13:31 */public class SpiTest { public static void main(String[] args) { ServiceLoader&lt;Search&gt; load = ServiceLoader.load(Search.class); // foreach example // for (Search search : load) { // search.doc(&quot;hello world&quot;); // } // iterator example Iterator&lt;Search&gt; searches = load.iterator(); while (searches.hasNext()) { Search search = searches.next(); search.doc(&quot;hello world&quot;); } }} 如果配置文件中填写 Search 的所有实现类结果应该如下 小结 SPI 实际上为面向接口编程。在一些框架中比较常见，如：Dubbo中的扩展实现、Spring中加载数据库驱动器、SpirngBoot中各starer自动装备等框架中使用。特别是统一标准的不同厂商实现，当有关组织或者公司定义标准之后，具体厂商或者框架开发者实现，之后提供给开发者使用。 本文的示例代码地址点击查看","link":"/java-spi/"},{"title":"","text":"内存可见性由于 Java 内存模型(JMM)规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速缓存)。 线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。 这里所提到的主内存可以简单认为是堆内存，而工作内存则可以认为是栈内存。 如下图所示： 所以在并发运行时可能会出现线程 B 所读取到的数据是线程 A 更新之前的数据。 显然这肯定是会出问题的，因此 volatile 的作用出现了： 当一个变量被 volatile 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。 volatile 修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中。 应用当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须的用 volatile 来修饰： 123456789101112131415161718192021222324@Datapublic class ThreadPool { private static volatile boolean initFlag = false; public static void main(String[] args) throws InterruptedException { new Thread(() -&gt; { System.out.println(&quot;wait true&quot;); while (!initFlag) { } System.out.println(&quot;=============== init SUCCESS&quot;); }).start(); Thread.sleep(20000); new Thread(() -&gt; build()).start(); } private static void build() { System.out.println(&quot;prepare data start&quot;); initFlag = true; System.out.println(&quot;prepare data end&quot;); }} 主线程在修改了标志位使得线程 A 立即停止，如果没有用 volatile 修饰，就有可能出现延迟。 但这里有个误区，这样的使用方式容易给人的感觉是： 对 volatile 修饰的变量进行并发操作是线程安全的。 这里要重点强调，volatile 并不能保证线程安全性！ 如下程序: 12345678910111213141516171819202122232425262728public class VolatileInc implements Runnable{ private static volatile int count = 0 ; //使用 volatile 修饰基本数据内存不能保证原子性 //private static AtomicInteger count = new AtomicInteger() ; @Override public void run() { for (int i=0;i&lt;10000 ;i++){ count ++ ; //count.incrementAndGet() ; } } public static void main(String[] args) throws InterruptedException { VolatileInc volatileInc = new VolatileInc() ; Thread t1 = new Thread(volatileInc,&quot;t1&quot;) ; Thread t2 = new Thread(volatileInc,&quot;t2&quot;) ; t1.start(); //t1.join(); t2.start(); //t2.join(); for (int i=0;i&lt;10000 ;i++){ count ++ ; //count.incrementAndGet(); } System.out.println(&quot;最终Count=&quot;+count); }} 当我们三个线程(t1,t2,main)同时对一个 int 进行累加时会发现最终的值都会小于 30000。 这是因为虽然 volatile 保证了内存可见性，每个线程拿到的值都是最新值，但 count ++ 这个操作并不是原子的，这里面涉及到获取值、自增、赋值的操作并不能同时完成。 所以想到达到线程安全可以使这三个线程串行执行(其实就是单线程，没有发挥多线程的优势)。 也可以使用 synchronize 或者是锁的方式来保证原子性。 还可以用 Atomic 包中 AtomicInteger 来替换 int，它利用了 CAS 算法来保证了原子性。 指令重排内存可见性只是 volatile 的其中一个语义，它还可以防止 JVM 进行指令重排优化。 举一个伪代码: 123int a=10 ;//1int b=20 ;//2int c= a+b ;//3 一段特别简单的代码，理想情况下它的执行顺序是：1&gt;2&gt;3。但有可能经过 JVM 优化之后的执行顺序变为了 2&gt;1&gt;3。 可以发现不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的。 可能这里还看不出有什么问题，那看下一段伪代码: 123456789101112131415161718private static Map&lt;String,String&gt; value ;private static volatile boolean flag = fasle ;//以下方法发生在线程 A 中 初始化 Mappublic void initMap(){ //耗时操作 value = getMapValue() ;//1 flag = true ;//2}//发生在线程 B中 等到 Map 初始化成功进行其他操作public void doSomeThing(){ while(!flag){ sleep() ; } //dosomething doSomeThing(value);} 这里就能看出问题了，当 flag 没有被 volatile 修饰时，JVM 对 1 和 2 进行重排，导致 value 都还没有被初始化就有可能被线程 B 使用了。 所以加上 volatile 之后可以防止这样的重排优化，保证业务的正确性。 应用一个经典的使用场景就是双重懒加载的单例模式了: 12345678910111213141516171819public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { //防止指令重排 singleton = new Singleton(); } } } return singleton; }} 这里的 volatile 关键字主要是为了防止指令重排。 如果不用 ，singleton = new Singleton();，这段代码其实是分为三步： 分配内存空间。(1) 初始化对象。(2) 将 singleton 对象指向分配的内存地址。(3) 加上 volatile 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。 总结volatile 在 Java 并发中用的很多，比如像 Atomic 包中的 value、以及 AbstractQueuedLongSynchronizer 中的 state 都是被定义为 volatile 来用于保证内存可见性。 将这块理解透彻对我们编写并发程序时可以提供很大帮助。 转载原文地址","link":"/"},{"title":"","text":"Kafka概念 Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。 Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。 Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。 Producer：负责发布消息到 Kafka broker。 Consumer：消息消费者，向 Kafka broker 读取消息的客户端。 Consumer Group：每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。 特性可扩展性、数据分区、低延迟、处理大量不同消费者的能力 应用场景docker-compose.yml12345678910111213141516171819202122version: '2'services: zookeeper: image: wurstmeister/zookeeper ports: - &quot;2181:2181&quot; kafka: image: wurstmeister/kafka depends_on: [ zookeeper ] ports: - &quot;9092:9092&quot; environment: KAFKA_ADVERTISED_HOST_NAME: 127.0.0.1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock kafka-manager: image: kafkamanager/kafka-manager ## 镜像：开源的web管理kafka集群的界面 environment: ZK_HOSTS: 127.0.0.1 ## 修改:宿主机IP ports: - &quot;9000:9000&quot; ## 暴露端口","link":"/"},{"title":"力扣 算法之两数之和","text":"力扣 算法练习 第一题：两数之和。 题目解析#1 两数之和 难度：简单 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 思路分析 使用双重 for 循环操作 123456789101112131415161718public int[] twoSum(int[] nums, int target) { // 2.优化2，让外出循环跳出 boolean flag = false; int[] a = new int[2]; for (int i = 0; i &lt; nums.length - 1 &amp;&amp; !flag; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] + nums[j] == target) { a[0] = i; a[1] = j; // 2.优化2，让外出循环跳出 flag = true; // 1.优化1，让内层循环跳出 break; } } } return a;} 使用 key-value 形式 12345678910111213public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] a = new int[2]; for (int i = 0; i &lt; nums.length; i++) { Integer reduce = map.get(target - nums[i]); if (reduce != null) { a = new int[]{reduce, i}; break; } map.put(nums[i], i); } return a;} 文章中的源码 点击 此处 查看。","link":"/leetcode-two-sum/"},{"title":"力扣 算法之两数相加（链表）","text":"力扣 算法练习 第二题：两数相加（链表）。 题目解析#2 两数相加（链表） 难度：中等 给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-two-numbers 思路分析 暴力解决(该方法放弃) 注： 由于题中链表所代表的数字可能会很大，导致该思路不可行，int、long、BigInteger 等都会超过数据范围。 123456789101112131415161718192021222324252627282930313233343536373839404142public ListNode addTwoNumbers(ListNode l1, ListNode l2) { StringBuffer buffer1 = new StringBuffer(); buffer1.append(l1.val); ListNode next1 = l1.next; while (null != next1) { buffer1.append(next1.val); next1 = next1.next; } StringBuffer buffer2 = new StringBuffer(); buffer2.append(l2.val); ListNode next2 = l2.next; while (null != next2) { buffer2.append(next2.val); next2 = next2.next; } BigInteger a = new BigInteger(buffer1.reverse().toString()); BigInteger b = new BigInteger(buffer2.reverse().toString()); BigInteger result = a.add(b); StringBuffer c = new StringBuffer(); c.append(result); String[] s = c.reverse().toString().split(&quot;&quot;); ListNode nodeSta = new ListNode(Integer.parseInt(s[0])); //创建首节点 ListNode nextNode; //声明一个变量用来在移动过程中指向当前节点 nextNode = nodeSta; //指向首节点 //创建链表 for (int i = 1; i &lt; s.length; i++) { ListNode node = new ListNode(Integer.parseInt(s[i])); //生成新的节点 nextNode.next = node; //把心节点连起来 nextNode = nextNode.next; //当前节点往后移动 } //当for循环完成之后 nextNode指向最后一个节点， nextNode = nodeSta; //重新赋值让它指向首节点 return nextNode;} 网友解法 1234567891011121314151617181920public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode root = new ListNode(0); ListNode cursor = root; int carry = 0; while(l1 != null || l2 != null || carry != 0) { int l1Val = l1 != null ? l1.val : 0; int l2Val = l2 != null ? l2.val : 0; int sumVal = l1Val + l2Val + carry; carry = sumVal / 10; ListNode sumNode = new ListNode(sumVal % 10); cursor.next = sumNode; cursor = sumNode; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } return root.next;} 文章中的源码 点击 此处 查看。","link":"/leetcode-add-two-numbers/"},{"title":"力扣 算法之无重复字符的最长子串","text":"力扣 算法练习 第三题：无重复字符的最长子串。 题目解析#3 无重复字符的最长子串 难度：中等 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 示例1: 123输入: s = &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 文章中的源码 点击 此处 查看。","link":"/longest-substring-without-repeating-characters/"},{"title":"力扣 算法之回文数","text":"力扣 算法练习 第九题：回文数。 题目解析#9 回文数 难度：简单 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 示例 1： 12输入：x = 121输出：true 示例 2： 123输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 123输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。 提示： -231&lt;= x &lt;= 231- 1 进阶： 你能不将整数转为字符串来解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-number 思路分析 使用 StringBuild 逆序后判断字符串是否相等 123456public boolean isPalindrome(int x) { String s = String.valueOf(x); StringBuilder sb = new StringBuilder(s); String reverse = sb.reverse().toString(); return s.equals(reverse);} 文章中的源码 点击 此处 查看。","link":"/leetcode-palindrome-number/"},{"title":"力扣 算法之罗马数字转整数","text":"力扣 算法练习 第十三题：罗马数字转整数。 题目解析#13 罗马数字转整数 难度：简单 罗马数字包含以下七种字符:I，V，X，L，C，D和M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做II，即为两个并列的 1 。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况： I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。 X可以放在L(50) 和C(100) 的左边，来表示 40 和90。 C可以放在D(500) 和M(1000) 的左边，来表示400 和900。 给定一个罗马数字，将其转换成整数。 示例1: 12输入:s = &quot;III&quot;输出: 3 示例2: 12输入:s = &quot;IV&quot;输出: 4 示例3: 12输入:s = &quot;IX&quot;输出: 9 示例4: 123输入:s = &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例5: 123输入:s = &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 &lt;= s.length &lt;= 15 s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’) 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/roman-to-integer 思路分析 Map 存储罗马值，判断前后字符对应值大小，相加所得和 12345678910111213141516171819202122232425262728293031323334public int romanToInt(String s) { // 优化1：将 Map 的 key 由 String -&gt; Character 可减小内存使用 // Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); // 优化1：将 s 转变成数组由 字符串数字-&gt; 字符数组 可减小内存使用 // String[] roman = s.split(&quot;&quot;); char[] roman = s.toCharArray(); int a = 0; for (int i = 0; i &lt; roman.length; i++) { if (i == roman.length - 1) { a += map.get(roman[roman.length - 1]); continue; } int left = map.get(roman[i]); int right = map.get(roman[i + 1]); if (left &gt;= right) { a += left; } else { a -= left; } } return a;} 文章中的源码 点击 此处 查看。","link":"/leetcode-roman-to-integer/"},{"title":"力扣 算法之最长公共前缀","text":"力扣 算法练习 第十四题：最长公共前缀。 题目解析#14 最长公共前缀 难度：简单 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串””。 示例 1： 12输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出：&quot;fl&quot; 示例 2： 123输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出：&quot;&quot;解释：输入不存在公共前缀。 提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 思路分析第一种方法取数组的第一个字符串，用此字符串来和剩余数组中字符串进行比较，然后判断数组中字符串是否以该字符串开始，如果不是则依次减去该字符串的末尾字符 123456789101112131415/** * 方法 1：随便找一个字符串,慢慢减少该字串长度,每减一次就比较一下 * 执行用时：0 ms , 在所有 Java 提交中击败了 100.00% 的用户 * 内存消耗：39.6 MB , 在所有 Java 提交中击败了 14.83% 的用户 */public String longestCommonPrefix(String[] strs) { String s = strs[0]; for (int i = 1; i &lt; strs.length; i++) { while (!strs[i].startsWith(s)) { s = s.substring(0, s.length() - 1); } } return s;} 第二种方法第二种方法是第一中方法的变体、优化 如果字符串 s 为空，则跳出循环 可以使用 strs[i].indexOf(s) == 0 代替 !strs[i].startsWith(s) 这里是否为优化的点，待后续研究String这两个方法的源码 1234567891011121314/** * 方法 2：方法1的变体、优化 * 执行用时：0 ms, 在所有 Java 提交中击败了 100.00% 的用户 * 内存消耗：39.1 MB, 在所有 Java 提交中击败了 53.27% 的用户 */public String longestCommonPrefix(String[] strs) { String s = strs[0]; for (int i = 1; i &lt; strs.length &amp;&amp; null != s &amp;&amp; !&quot;&quot;.equals(s); i++) { while (!strs[i].startsWith(s)) { s = s.substring(0, s.length() - 1); } } return s;} 文章中的源码 点击 此处 查看。 文章中的源码 点击 此处 查看。","link":"/leetcode-longest-common-prefix/"},{"title":"力扣 算法之有效的括号","text":"力扣 算法练习 第二十题：有效的括号。 题目解析#20 有效的括号 难度：简单 给定一个只包括 (，)，{，}，[，]的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例2： 12输入：s = &quot;()[]{}&quot;输出：true 示例3： 12输入：s = &quot;(]&quot;输出：false 示例4： 12输入：s = &quot;([)]&quot;输出：false 示例5： 12输入：s = &quot;{[]}&quot;输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 ()[]{} 组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 思路分析第一种方法成对的字符串符合栈数据结构，先进后出 原则。 首先遍历字符串遇到符号左边字符，则将其的右边对应符号压入栈中； 如果遇到符号的右边字符，则从栈顶取出字符判断是否和当前字符一致如果不一致则可以判断出不是有效符号字符串 循环结束后如果栈为空则为有效符号字符串，反之不是。 1234567891011121314151617181920212223/** * 执行用时： 1 ms , 在所有 Java 提交中击败了 98.84% 的用户 * 内存消耗： 39.1 MB , 在所有 Java 提交中击败了 61.69% 的用户 */public boolean isValid(String s) { if (s.length() % 2 != 0) { return false; } Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { if (chars[i] == '(') { stack.push(')'); } else if (chars[i] == '[') { stack.push(']'); } else if (chars[i] == '{') { stack.push('}'); } else if (stack.isEmpty() || chars[i] != stack.pop()) { return false; } } return stack.isEmpty();} 文章中的源码 点击 此处 查看。","link":"/leetcode-valid-parentheses/"},{"title":"力扣 算法之合并两个有序链表","text":"题目解析#21 合并两个有序链表 难度：简单 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 = [], l2 = []输出：[] 示例 3： 12输入：l1 = [], l2 = [0]输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 思路分析第一种方法成对的字符串符合栈数据结构，先进后出原则。 首先遍历字符串遇到符号左边字符，则将其的右边对应符号压入栈中； 如果遇到符号的右边字符，则从栈顶取出字符判断是否和当前字符一致如果不一致则可以判断出不是有效符号字符串 循环结束后如果栈为空则为有效符号字符串，反之不是。 1234567891011121314151617181920212223/** * 执行用时： 1 ms , 在所有 Java 提交中击败了 98.84% 的用户 * 内存消耗： 39.1 MB , 在所有 Java 提交中击败了 61.69% 的用户 */public boolean isValid(String s) { if (s.length() % 2 != 0) { return false; } Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { if (chars[i] == '(') { stack.push(')'); } else if (chars[i] == '[') { stack.push(']'); } else if (chars[i] == '{') { stack.push('}'); } else if (stack.isEmpty() || chars[i] != stack.pop()) { return false; } } return stack.isEmpty();} 文章中的源码 点击 此处 查看。","link":"/leetcode-merge-two-sorted-lists/"},{"title":"力扣 算法之删除有序数组中的重复项","text":"题目解析力扣 算法练习 第二十六题：删除有序数组中的重复项。不使用额外的数组空间，空间复杂度 O(1)。 #26 删除有序数组中的重复项 难度：简单 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么nums的前 k 个元素应该保存最终结果。 将最终结果插入nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) {assert nums[i] == expectedNums[i];} 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 升序 排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 思路分析将满足条件的数组元素从零开始比较将不等于前一元素插入原数组中，记录 index，数组尾数不考虑。 123456789101112131415/** * 执行用时： 0 ms , 在所有 Java 提交中击败了 100.00% 的用户 * 内存消耗： 40.1 MB , 在所有 Java 提交中击败了 11.24% 的用户 */public int removeDuplicates(int[] nums) { int index = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[index] != nums[i]) { nums[index + 1] = nums[i]; index++; } } return index + 1;} 文章中的源码 点击 此处 查看。","link":"/leetcode-remove-duplicates-from-sorted-array/"},{"title":"力扣 算法之移除元素","text":"力扣 算法练习 第二十七题：移除元素。不使用额外的数组空间，空间复杂度 O(1)。 题目解析#27 删除有序数组中的重复项 难度：简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 思路分析将满足条件的数组元素从零开始插入原数组中，记录 index，数组尾数不考虑。 12345678910111213141516/** * 执行用时： 0 ms , 在所有 Java 提交中击败了 100.00% 的用户 * 内存消耗： 40.1 MB , 在所有 Java 提交中击败了 11.24% 的用户 */public int removeElement(int[] nums, int val) { int index = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != val) { nums[index] = nums[i]; index++; } } return index;} 文章中的源码 点击 此处 查看。","link":"/leetcode-remove-element/"},{"title":"力扣 算法之实现 strStr()","text":"力扣 算法练习 第二十七题：实现 strStr()。 题目解析#28 实现 strStr() 难度：简单 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 12输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2 示例 2： 12输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1 示例 3： 12输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0 提示： 120 &lt;= haystack.length, needle.length &lt;= 5 * 104haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/implement-strstr 思路分析方法一直接使用 Java 的 indexOf() 方法进行处理。 使用 API 库该题：简单 使用 KMP 算法：困难 123public int strStr(String haystack, String needle) { return haystack.indexOf(needle);} 文章中的源码 点击 此处 查看。","link":"/leetcode-implement-strstr/"},{"title":"力扣 算法之搜索插入位置","text":"力扣 算法练习 第三十五题：搜索插入位置。 题目解析#35 搜索插入位置 难度：简单 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 思路分析使用 for 循环进行判断，如果 target 值小于当前值，当前 i 即为返回值，反之继续循环。 1234567891011121314151617/** * 执行用时： 0 ms , 在所有 Java 提交中击败了 100.00% 的用户 * 内存消耗： 40.9 MB , 在所有 Java 提交中击败了 40.24% 的用户 */public int searchInsert(int[] nums, int target) { int index = 0; for (int i = 0; i &lt; nums.length; i++) { if (target &lt;= nums[i]) { index = i; break; } else { index = i + 1; } } return index;} 文章中的源码 点击 此处 查看。","link":"/leetcode-search-insert-position/"},{"title":"力扣 算法之最大子数组和","text":"力扣 算法练习 第五十三题：最大子数组和。 题目解析#53 最大子数组和 难度：简单 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = `[-2,1,-3,4,-1,2,1,-5,4]`输出：6解释：连续子数组 `[4,-1,2,1]` 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 思路分析","link":"/leetcode-maximum-subarray/"},{"title":"MySQL 事务隔离级别","text":"MySQL 的事务隔离级别以及常见问题。 4种事务隔离级别 序列化 SERIALIZABLE 可重复读 REPEATABLE READ 读已提交 READ COMMITTED 读未提交 READ UNCOMMITTED MySQL 事务隔离级别操作查看事务隔离级别MySQL5.7 及以前 1SELECT @@GLOBAL.tx_isolation, @@tx_isolation; MySQL5.7+ 1SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation; 只是关键字变了，其他没有变化 修改事务隔离级别语法格式 1SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} session 修改 1SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 全局修改 1SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SESSION：当前会话，GLOBAL：为本次连接所有会话。 修改 session 新建一个 session 设置失效。（在 Navicat 中重新打开一个窗口即对应一个新的 session） 修改 GLOBAL 重新建立连接 设置失效。 无论是 SESSION 还是 GLOBAL 级别，断开 MySQL 连接下次再连接的时候，还是原来的事务隔离级别。因此彻底更新MySQL 事务隔离级别，需要修改 MySQL 配置文件，配置文件修改之后需要重启 MySQL 服务 MySQL 默认的事务隔离级别为 REPEATABLE READ MySQL 事务隔离级别详解事务隔离级别常见的问题 脏读： 读取未提交的数据 事务A读取到事务B回滚前的数据。 幻读： 前后数据多次读取，结果集数量不一致 事务A的按查询条件先后两次读取数据笔数不一致。例如有事务A查询了M条数据，而事务B却在此时插入了N条数据，事务A在接下来的查询中，就会发现有M条数据是它先前所没有的。 不可重复读： 前后数据多次读取，结果集内容不一致 事务A先后读取同一条记录，但两次读取的数据不同。这可能是事务A两次查询过程中间插入了一个事务B更新的原有的数据。 修改事务自动提交查看事务自动提交 1SHOW VARIABLES LIKE '%autocommit%'; 设置关闭自动提交 1SET autocommit = OFF; 序列化 SERIALIZABLESERIALIZABLE 提供了事务之间最大限度的隔离。 在这种隔离级别中，开启事务时就会阻塞，必须等当前事务提交了，其他事务才能开启成功。 事务一个接一个顺序的执行，不会发生脏读、不可重复读及幻读问题，最安全，但执行效率慢。 可重复读保证了同一事务下多次读取相同的数据返回的结果是一样的。 可能出现幻读。 MySQL 默认事务隔离机制。 读已提交事务B只能读取到其他事务已经提交的执行结果。 可能出现幻读、不可重复读。 读未提交事务A均可查看到其他事务未提交的执行结果。 性能好，但可能出现脏读、幻读、不可重复读。 读操作 START TRANSACTION;SELECT 语句;COMMIT; 更新操作 START TRANSACTION;UPDATE 语句;COMMIT; 事务隔离级别 脏读 不可重复读 幻读 序列化 × × × 可重复读 × × √ 读已提交 × √ √ 读未提交 √ √ √ 相关问题MySQL 如何实现可重复读的？使用 MVCC 实现的， 即 Mutil-Version Concurrency Control，多版本并发控制。","link":"/mysql-transaction-isolation-level/"},{"title":"","text":"MySQL主从复制环境搭建 目录结构 1234567891011121314主从复制 │ docker-compose.yml │ ├─master │ Dockerfile │ my.cnf │ ├─slave-1 │ Dockerfile │ my.cnf │ └─slave-2 Dockerfile my.cnf docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950version: '3'services: master: build: context: ./master dockerfile: Dockerfile image: mysql-master:1.0 volumes: - &quot;./master/mysql-files:/var/lib/mysql-files/&quot; container_name: mysql-master links: - slave-1 - slave-2 ports: - &quot;33077:3306&quot; restart: always hostname: mysql-master environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; slave-1: build: context: ./slave-1 dockerfile: Dockerfile image: mysql-slave-1:1.0 volumes: - &quot;./slave-1/mysql-files:/var/lib/mysql-files/&quot; ports: - &quot;33070:3306&quot; restart: always hostname: mysql-slave-1 container_name: mysql-slave-1 environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; slave-2: build: context: ./slave-2 dockerfile: Dockerfile image: mysql-slave-2:1.0 volumes: - &quot;./slave-2/mysql-files:/var/lib/mysql-files/&quot; restart: always ports: - &quot;33071:3306&quot; hostname: mysql-slave-2 container_name: mysql-slave-2 environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; master中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./master/mysql-files /var/lib/mysql-files/ my.cnf 123456789[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 10## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin## 主从复制的格式（mixed,statement,row，默认格式是statement）## binlog_format = row slave-1中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./slave-1/mysql-files /var/lib/mysql-files/ my.cnf 123456[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 11## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin slave-2中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./slave-2/mysql-files /var/lib/mysql-files/ my.cnf 123456[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 12## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin 环境配置 运行 docker-compose up -d 停止 docker-compose down master 配置 12345678910111213141516#添加用户/权限CREATEUSER 'repl'@'%' IDENTIFIED WITH 'mysql_native_password' BY '123456';#创建用户GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';#分配权限FLUSH PRIVILEGES;#刷新权限# 查看主库状态SHOW MASTER STATUS;SHOWVARIABLES LIKE '%server_uuid%';SHOWVARIABLES LIKE '%server_id%'; slave 配置(所有从库都一样) 1234567891011121314151617SHOWSLAVE STATUS;STOPSLAVE;CHANGEMASTER TO MASTER_HOST = 'mysql-master',MASTER_USER = 'repl',MASTER_PASSWORD = '123456',MASTER_LOG_FILE = 'mysql-bin.000003',MASTER_LOG_POS = 818;STARTSLAVE;SHOWVARIABLES LIKE '%server_uuid%';SHOWVARIABLES LIKE '%server_id%';","link":"/"},{"title":"","text":"主从复制、读写分离基本环境 java: 1.8 maven：3.6.0 mysql: 8.0 springboot:2.4.4 docker: 20.10.5 docker-compose: 1.28.5 sharding-jdbc: sharding-jdbc-spring-boot-starter:4.1.1 主从复制环境搭建 目录结构 1234567891011121314主从复制 │ docker-compose.yml │ ├─master │ Dockerfile │ my.cnf │ ├─slave-1 │ Dockerfile │ my.cnf │ └─slave-2 Dockerfile my.cnf docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950version: '3'services: master: build: context: ./master dockerfile: Dockerfile image: mysql-master:1.0 volumes: - &quot;./master/mysql-files:/var/lib/mysql-files/&quot; container_name: mysql-master links: - slave-1 - slave-2 ports: - &quot;33077:3306&quot; restart: always hostname: mysql-master environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; slave-1: build: context: ./slave-1 dockerfile: Dockerfile image: mysql-slave-1:1.0 volumes: - &quot;./slave-1/mysql-files:/var/lib/mysql-files/&quot; ports: - &quot;33070:3306&quot; restart: always hostname: mysql-slave-1 container_name: mysql-slave-1 environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; slave-2: build: context: ./slave-2 dockerfile: Dockerfile image: mysql-slave-2:1.0 volumes: - &quot;./slave-2/mysql-files:/var/lib/mysql-files/&quot; restart: always ports: - &quot;33071:3306&quot; hostname: mysql-slave-2 container_name: mysql-slave-2 environment: - &quot;MYSQL_ROOT_PASSWORD=123456&quot; master中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./master/mysql-files /var/lib/mysql-files/ my.cnf 123456789[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 10## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin## 主从复制的格式（mixed,statement,row，默认格式是statement）## binlog_format = row slave-1中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./slave-1/mysql-files /var/lib/mysql-files/ my.cnf 123456[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 11## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin slave-2中DockerFile和my.cnf DockerFile 1234FROM mysql:latestMAINTAINER masilyADD ./my.cnf /etc/mysql/my.cnf#ADD ./slave-2/mysql-files /var/lib/mysql-files/ my.cnf 123456[mysqld]## 设置server_id，一般设置为IP，注意要唯一server-id = 12## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin = mysql-bin 环境配置 运行 docker-compose up -d 停止 docker-compose down master 配置 12345678910111213141516#添加用户/权限CREATEUSER 'repl'@'%' IDENTIFIED WITH 'mysql_native_password' BY '123456';#创建用户GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';#分配权限FLUSH PRIVILEGES;#刷新权限# 查看主库状态SHOW MASTER STATUS;SHOWVARIABLES LIKE '%server_uuid%';SHOWVARIABLES LIKE '%server_id%'; slave 配置(所有从库都一样) 1234567891011121314151617SHOWSLAVE STATUS;STOPSLAVE;CHANGEMASTER TO MASTER_HOST = 'mysql-master',MASTER_USER = 'repl',MASTER_PASSWORD = '123456',MASTER_LOG_FILE = 'mysql-bin.000003',MASTER_LOG_POS = 818;STARTSLAVE;SHOWVARIABLES LIKE '%server_uuid%';SHOWVARIABLES LIKE '%server_id%'; 读写分离环境配置maven 依赖123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 没有用druid使用该数据库连接池启动报错，后期排查 --&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!-- &lt;version&gt;1.2.5&lt;/version&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt;&lt;/dependencies&gt; yml 配置123456789101112131415161718192021222324252627282930313233343536373839404142spring: jpa: database: mysql hibernate: ddl-auto: update shardingsphere: enabled: true # 数据源配置 datasource: names: ds0,ds1,ds2 ds0: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://localhost:33077/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: 123456 ds1: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://localhost:33070/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: 123456 ds2: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://localhost:33071/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: 123456 # 读写分离 masterslave: name: ds # 主库数据源名称 master-data-source-name: ds0 # 从库数据源名称列表 slave-data-source-names: - ds1 - ds2 # 读写分离负载算法的属性配置 load-balance-algorithm-type: ROUND_ROBIN props: sql.show: true 启动试试 complete！ 🎉🎉🎉 常见问题 主从复制原理 主库更新事件写入到binlog中 从库发起连接，连接到主库 主库创建一个SQL线程（binlog dump thread线程），把发送binlog内容到从库中；从库创建两个线程 从库IO线程：当START SLAVE 执行后，从库创建一个I/O线程，读取主库发送过来的binlog内容写入到relay log(中继日志)中 从库SQL线程：从库创建SQL线程，从relay log里读取内容从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到从库中 主从同步事件有3种形式:statement、row、mixed。 statement：会将对数据库操作的sql语句写入到binlog中。 row：会将每一条数据的变化写入到binlog中。 mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。 主从复制策略 同步策略：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。 半同步策略：Master至少会等待一个Slave回应后提交。 异步策略：Master不用等待Slave回应就可以提交。 延迟策略：Slave要落后于Master指定的时间。 解决主从延迟 在使用的sharding-jdbc中已有处理机制，更新和查询处于同一事务的话，强行走主库 主从复制有不同的复制策略，对于不同的场景的适应性也不同，对于数据的实时性要求很高，要求强一致性，可以采用同步复制策略，但是这样就会性能就会大打折扣。 若是主从复制采用异步复制，要求数据最终一致性，性能方面也会好很多。只能说，对于数据延迟的解决方案没有最好的方案，就看你的业务场景中哪种方案使比较适合的。 若是主从复制，达到了写性能的瓶颈？ 主从模式对于写少读多的场景确实非常大的优势，但是总会写操作达到瓶颈的时候，导致性能提不上去。 这时候可以在设计上进行解决采用分库分表的形式，对于业务数据比较大的数据库可以采用分表，使得数据表的存储的数据量达到一个合理的状态。 也可以采用分库，按照业务进行划分，这样对于单点的写，就会分成多点的写，性能方面也就会大大提高。 Mysql主从有什么优点？为什么要选择主从？ 高性能方面：主从复制通过水平扩展的方式，解决了原来单点故障的问题，并且原来的并发都集中到了一台Mysql服务器中，现在将单点负载分散到了多台机器上，实现读写分离，不会因为写操作过长锁表而导致读服务不能进行的问题，提高了服务器的整体性能。 可靠性方面：主从在对外提供服务的时候，若是主库挂了，会有通过主从切换，选择其中的一台Slave作为Master；若是Slave挂了，还有其它的Slave提供读服务，提高了系统的可靠性和稳定性。","link":"/"},{"title":"MySQL 开窗函数","text":"","link":"/mysql-olap/"},{"title":"","text":"Spring Could集群分布式微服务微服务就是将一个项目中的小功能都分为一个个微小的服务，并且独立运行在自己的进程中，要用了再分别调用就行。 Spring CouldSpringCloud及时一个大集合：包括了配置中心、注册中心、负责均衡、熔断处理等等一些成熟的框架，并用 Spring boot 的形式包装好，方便开发者使用。框架集合 Spring Cloud Config配置中心，将系统中用到的一些配置信息存储到配置中心，方便维护，不用每次修改配置都重启服务。用的比较多的配置中心还有etcd、携程的 Apollo、Disconf。 Spring Cloud NetflixNetflix OSS 是一组开源的框架和组件库，是Netflix公司开发出来解决分布式系统的一些有趣的可扩展类库。Spring Cloud 把他们都放到 Spring Cloud Netflix 下，这是一个框架集合，它包括 Eureka 、Ribbon、Zuul、Hystrix 等。 Eureka服务中心，这可以说是微服务架构的核心功能了，微服务部署之后，一定要有服务注册和发现的能力，Eureka 就是担任这个角色的。如果你用过 dubbo 的话，那一定知道 dubbo 中服务注册和发现的功能是用 zookeeper 来实现的。 Ribbon提供客户端负责均衡功能，例如一个服务提供者部署了 3 个实例，那么使用 Ribbon 可以指定负载均衡算法请求其中一个实例，Ribbon 如果配合 Eureka ，使用起来非常简单。 Hystrix熔断器，假设有 3 个服务提供实例，其中有一个实例由于某中原因挂掉了，那么当再有请求进来的时候，如果还是向这个实例上发请求，那将会导致请求积压阻塞，这个时候，熔断器就要发挥它的作用，将这个有问题的实例下线，这样一来，再有新的请求进来，就不会再发到这个有问题的实例上了。 Zuul服务网关。主要实现了路由转发和过滤器功能，对于处理一些数据聚合、鉴权、监控、统计类的功能非常好用。 Gateway也是服务网关，可以认为它是 Zuul 的下一代，无论从易用性和性能方便都有所提高，如果你的系统中还没有使用 Zuul ，并且准备上网关，可以直接选择 Gateway 。 Spring Cloud ConsulConsul 让服务注册和服务发现（通过 DNS 和 HTTP 接口）更加简单，甚至对于外部服务（例如SaaS）注册也一样。Spring Cloud Consul 可替代已有的 Spring Cloud Eureka。Eureka 2.x 版本也已经停止开发，并且 Spring Cloud 官方也建议用 Spring Cloud Consul 来替代，当然如果已经用了 Eureka 在项目中也没有关系，Eureka 已经足够稳定，正常使用没有任何问题。Spring Cloud Consul 可替代已有的 Spring Cloud Config ，当做配置中心使用。 Spring Cloud StreamSpring Cloud Stream 是消息中间件组件，它集成了 kafka 和 rabbitmq 。如果你的系统中打算集成 kafka 或 rabbitmq，可以考虑使用 Stream 。 Spring Cloud Bus消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。集成了 Rabbitmq 和 kafka 。刚刚上面说到的 Stream 好像也是这个功能。没错，我们可以认为 Bus 是 Stream 的进一步封装，使用更简单。而 Stream 的灵活性更高。 Spring Cloud FeignFeign是一种声明式、模板化的HTTP客户端。它可以用注解的方式简化 HTTP 请求，可以快速简单的请求服务提供接口。如果你还在使用 restTemplate 或者其他方式，不妨考虑一下 Feign。 Spring Cloud Sleuth服务日志收集和链路追踪模块，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作。与之功能相同的框架还有 skywalking、Pinpoint，另外国内还有美团开源的 CAT，只不过 CAT 属于代码侵入的，需要开发人员在系统中做代码埋点，不过也更加灵活，更加精细。 Spring Cloud Security可用做授权服务、单点登录等。如果服务需要做权限控制，那除非你自己实现。不然用到最多的就是 shiro 和 Spring Security 。Spring Boot 中用的比较多的就是 Security，众多授权机制中属于 OAuth2 最为流行。Spring Cloud Security 就是将 Security、OAuth2 做了集成，方便使用。 Spring cloud Hystrix 熔断器断路器(Cricuit Breaker)是一种能够在远程服务不可用时自动熔断(打开开关)，并在远程服务恢复时自动恢复(闭合开关)的设施。断路器(Cricuit Breaker)是一种能够在远程服务不可用时自动熔断(打开开关)，并在远程服务恢复时自动恢复(闭合开关)的设施，Spring Cloud通过Netflix的Hystrix组件提供断路器、资源隔离与自我修复功能。 Spring Cloud Zuul 服务网关","link":"/"},{"title":"Arthas 简单使用之热更新","text":"本篇主要记录阿里开源工具 Arthas 的安装使用以及在不重启服务的情况下进行服务的热更新。 Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到 JVM 的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 怎样直接从 JVM 内查找某个类的实例？ 安装 下载 arthas-boot.jar 启动 arthas-boot.jar 1java -jar arthas-boot.jar 选择程序的PID，进入程序中 热更新 查找/反编译源文件 12# 使用 sc 查看JVM已加载的类信息(以Test类为示例)sc com.masily.Test 使用 jad 反编译 Test 类 使用 idea 修改 Test 类 修改后编译成 class 字节码 上传到服务器中 使用 redefine 进行热更新 123# 注：Windows 文件路径需要加转义符 `/`# 如 redefine D://arthas//classes//Test.classredefine /usr/local/arthas/classes/Test.class 控制台返回 12# 当返回success时,表示代码已在jvm中重新加载redefine success, size: 1","link":"/tool-arthas/"},{"title":"程序员常用的绘图工具","text":"在开发工作种时长需要绘制一些图表（流程图、时序图、ER图、思维导图等），为此分享一些常用的绘图工具。比如常见的 processOn、xmind、excalidraw 等 processOn推荐指数：⭐⛤⛤⛤⛤ 使用途径：线上 拥有常用的流程图、时序图、ER图、思维导图等基本涵括，免费功能受限，存储云端文件数量较少。充值使我强大 draw.io推荐指数：⭐⭐⭐⭐⭐ 使用途径：线上 、客户端 拥有几乎所有的图形，免费，支持国际化，可下载本地或存储网盘。推荐 excalidraw推荐指数：⭐⭐⭐⭐⭐ 使用途径：线上1 、线上2 开源地址 ，绘图更像手绘，免费，支持国际化。推荐 XMind推荐指数：⭐⭐⛤⛤⛤ 使用途径：客户端 拥有常用的流程图、时序图、ER图、思维导图等基本涵括，收费，不支持Web端绘图。充值使我强大","link":"/tool-draw/"},{"title":"Homebrew 安装使用","text":"Homebrew 在 Mac 中使用广泛的包管理器。 安装配置 https://brew.sh/ 官网查看安装命令 可能下载过慢，可以使用代理进行安装（复制代理配置到控制台） 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 配置国内源 1234567891011121314# brew 程序本身，Homebrew/Linuxbrew 相同git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 以下针对 mac OS 系统上的 Homebrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/linuxbrew-core.git # 更换后测试工作是否正常brew update 应用MySQL 安装1brew install mysql Navicat 安装1brew install --cask navicat-premium --language &quot;zh-CN&quot; JDK 安装12345678910111213141516#link https://devqa.io/brew-install-java/# jdk8brew install --cask adoptopenjdk8# jdk11brew install --cask adoptopenjdk11# 可切换jdkexport JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)export JAVA_11_HOME=$(/usr/libexec/java_home -v11)alias java8='export JAVA_HOME=$JAVA_8_HOME'alias java11='export JAVA_HOME=$JAVA_11_HOME'# default to Java 11java11Reload .bash_profile for the aliases to take effect:source ~/.bash_profile 或 source ~/.zshrc NVM 安装123456export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$(brew --prefix)/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;$(brew --prefix)/opt/nvm/nvm.sh&quot; # This loads nvm[ -s &quot;$(brew --prefix)/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;$(brew --prefix)/opt/nvm/etc/bash_completion.d/nvm&quot; # This loads nvm bash_completionReload .bash_profile for the aliases to take effect:source ~/.bash_profile 或 source ~/.zshrc NVM 使用见 NVM 使用","link":"/tool-homebrew/"},{"title":"macOS 系统使用自带终端进行 ssh、sftp、scp 操作","text":"前言平时我们在进行部署服务、更新服务等操作时，时常需要借助 SSH 工具和 FTP 工具进行远程登录进行操作。 本文讲述在 macOS 系统中使用终端进行 ssh、sftp、scp 等远程操作。 常见的几款工具 SecureCRT 和 SecureFX Mobaxterm XShell和 XFTP WinSCP 和 FileZilla PuTTY 开始SSH 远程登录 新建远程连接 选择 安全Shell SSH ，添加服务器，填入用户名和服务器IP，并进行连接 输入密码，开始愉快的玩耍 或者通过命令方式进行连接登录 ssh -p 端口 用户名@ip地址 示例: ssh -p 22 root@192.168.13.14 SFTP 远程文件传输 如上述 SSH 方式一样，新建远程连接终端 选择安全文件传输 SFTP ，添加服务器，填入用户名和服务器IP，并进行连接 输入密码，开始愉快的玩耍 或通过命令方式进行连接登录 sftp 用户名@ip地址 示例: sftp root@192.168.13.14 上传文件12put -r 本地路径 远程路径# 示例: put -r /Users/local/test.zip /home/remote/root/ 上传文件夹12put -r 本地路径/文件夹/* 远程路径/新建文件夹/# 示例: put -r /Users/local/testFolder/* /home/remote/newFolder/ 下载文件12get -r 远程路径 本地路径# 示例：get -r /home/remote/test.zip /Users/local/ 下载文件夹12get -r 远程路径/文件夹/* 本地路径/新建文件夹/# 示例：get -r /home/remote/myFolder/* /Users/local/newFolder/ SCP 文件copy 远程拷贝到本地 123scp -r 用户名@IP地址:远程路径 本地路径# 示例： scp -r root@192.168.13.14:/home/remote/test.zip /Users/local/# 示例： scp -r root@192.168.13.14:/home/remote/myFolder/ /Users/local/ 本地拷贝到远程 123scp -r 本地路径 用户名@IP地址:远程路径 # 示例：scp -r /Users/local/test.zip root@192.168.13.14:/home/remote/ # 示例：scp -r /Users/local/myFolder/ root@192.168.13.14:/home/remote/ 小结 个人在 Windows 中推荐 Mobaxterm,该工具分免费版本和收费版本的，免费版本已经很强大了，足够日常的使用了。集成了 SSH 和 FTP，使用起来方便快捷，界面整洁美观。 Mobaxterm 下载地址","link":"/tool-mac-ssh-sftp-scp/"},{"title":"NVM 使用","text":"NVM 是可切换 Node 版本的工具，再 Node 多版本使用中是比较好的选择。 安裝NVM之前，一律建议您从系统中移除任何现有的 Node.js 或 npm 安裝，因为不同类型的安装可能导致奇怪且困惑的冲突。 Run npm cache clean --force Uninstall from Programs &amp; Features with the uninstaller. Reboot (or you probably can get away with killing all node-related processes from Task Manager). Look for these folders and remove them (and their contents) if any still exist. Depending on the version you installed, UAC settings, and CPU architecture, these may or may not exist: C:\\Program Files (x86)\\NodejsC:\\Program Files\\NodejsC:\\Users{User}\\AppData\\Roaming\\npm (or %appdata%\\npm)C:\\Users{User}\\AppData\\Roaming\\npm-cache (or %appdata%\\npm-cache)C:\\Users{User}.npmrc (and possibly check for that without the . prefix too)C:\\Users{User}\\AppData\\Local\\Temp\\npm-* Check your %PATH% environment variable to ensure no references to Nodejs or npm exist. 这包括刪除任何现有的 nodejs 安裝目录 (例如，可能会保留的 “C:\\Program Files\\nodejs” ) 。 NVM 产生的连接将不会覆盖现有的（甚至是空的）安装目录。 https://stackoverflow.com/questions/20711240/how-to-completely-remove-node-js-from-windows如需移除先前安裝的说明，請參閱如何從 Windows 完全移除 node.js。 ) 确保卸载系统中的 nodejs windows 开源库地址，下载地址 在 nvm 安装根路径找到 setting.txt 加入下载源的设置node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ npm instal version npm use version npm list npm uninstall version","link":"/tool-nvm/"},{"title":"科学上网","text":"金克拉记录几款科学上网地址。 最低套餐：￥10.8/moth146GB/month 链接 Github mosucloud 最低套餐：￥48/6moth24GB/month 链接 店铺店铺 1店铺 2","link":"/tool-ssr/"},{"title":"","text":"springboot websocket环境springboot 2.3.5.RELEASE 步骤传统方式使用websocket 依赖 12345&lt;!--虽然springboot中存在websocket依赖，但是使用传统开发还是需要该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 配置 1234567891011121314151617181920package com.masily.websocket;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configurationpublic class WebSocketConfig { /** * 这个bean会自动注册使用了@ServerEndpoint注解声明的对象 * 没有的话会报404 * * @return */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); }} websocket逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.masily.websocket;import com.fasterxml.jackson.databind.ObjectMapper;import com.masily.websocket.entity.Message;import lombok.*;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet;/** * @author masily * @date 2020-12-15 08:29:26 * 类似Servlet的注解mapping。无需在web.xml中配置。 * configurator = SpringConfigurator.class是为了使该类可以通过Spring注入。好像还需要添加的jar为：spring-websocket-4.3.8.RELEASE 暂且不用 * 当前 objectMapper 会无法注入 null */@Data@Slf4j@Component// @ServerEndpoint(value = &quot;/websocket/chat&quot;, configurator = SpringConfigurator.class)@ServerEndpoint(value = &quot;/websocket/chat&quot;)public class MyWebSocket { @Resource private ObjectMapper objectMapper; private Session session; /** * 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 */ private static int onLineCount = 0; /** * concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 * 若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识 */ private static CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;&gt;(); /** * 连接建立成功调用的方法 * * @param session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据 */ @OnOpen public void onOpen(Session session) { this.session = session; //加入set中 webSocketSet.add(this); //在线数加1 addOnlineCount(); log.info(&quot;有新连接加入！当前在线人数为&quot; + onLineCount); sendOnLineCountMessage(); } /** * 连接关闭调用的方法 */ @OnClose public void onClose() { //从set中删除 webSocketSet.remove(this); //在线数减1 subOnlineCount(); log.info(&quot;有一连接关闭！当前在线人数为&quot; + onLineCount); sendOnLineCountMessage(); } /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息 * @param session 可选的参数 */ @OnMessage public void onMessage(String message, Session session) { System.out.println(&quot;来自客户端的消息:&quot; + message); //群发消息 groupSendMessage(Message.sendMessage(message)); } /** * 发生错误时调用 * * @param session 可选的参数 * @param error 异常 */ @OnError public void onError(Session session, Throwable error) { log.error(&quot;发生错误,session:{},e:{}&quot;, session, error); } /** * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。 * * @param message 客户端发送过来的消息 * @throws IOException */ public &lt;T&gt; void sendMessage(Message&lt;T&gt; message) throws IOException { String msg = objectMapper.writeValueAsString(message); this.session.getBasicRemote().sendText(msg); } /** * 发送在线数量 */ public void sendOnLineCountMessage() { groupSendMessage(Message.sendOnLineCount(onLineCount)); } public &lt;T&gt; void groupSendMessage(Message&lt;T&gt; message) { for (MyWebSocket item : webSocketSet) { try { item.sendMessage(message); } catch (IOException e) { e.printStackTrace(); continue; } } } public static synchronized void addOnlineCount() { MyWebSocket.onLineCount++; } public static synchronized void subOnlineCount() { MyWebSocket.onLineCount--; }} 使用最新的开发","link":"/"},{"title":"","text":"zookeeperdocker-compose.yml12345678910111213141516171819202122232425262728293031323334version: '2'services: zoo1: image: zookeeper restart: always container_name: zoo1 # 本地地址：容器内部地址 ports: - &quot;2181:2181&quot; environment: # ZK 服务的 id, 它是1-255 之间的整数, 必须在集群中唯一. ZOO_MY_ID: 1 # ZK 集群的主机列表. ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo2: image: zookeeper restart: always container_name: zoo2 ports: - &quot;2182:2181&quot; environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo3: image: zookeeper restart: always container_name: zoo3 ports: - &quot;2183:2181&quot; environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zookeeper 相关配置zookeeper 的三个端口作用 2181 : 对 client 端提供服务 2888 : 集群内机器通信使用 3888 : 选举 leader 使用 zookeeper 集群配置按 server.id = ip:port:port 修改集群配置文件: 三台虚拟机 zoo.cfg 文件末尾添加配置: server.1=192.168.3.33:2888:3888 server.2=192.168.3.35:2888:3888 server.3=192.168.3.37:2888:3888 根据 id 和对应的地址分别配置 myid 1vim /tmp/zookeeper/myid","link":"/"},{"title":"23种设计模式","text":"所谓“模式”，就是一套反复被人使用或验证过的方法论。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性。 可以理解为：”世上本来没有设计模式，用的人多了，便总结出了一套设计模式。“ 七大基本原则(SOLID) 面向对象的设计模式有七大基本原则： 开闭原则（Open Closed Principle，OCP） 单一职责原则（Single Responsibility Principle, SRP） 里氏代换原则（Liskov Substitution Principle，LSP） 依赖倒转原则（Dependency Inversion Principle，DIP） 接口隔离原则（Interface Segregation Principle，ISP） 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP） 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD） 创建型模式工厂模式抽象工厂模式单例模式 懒汉 饿汉 静态内部类 枚举 建造者模式原型模式结构型模式适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型模式策略模式模板模式观察者模式迭代器模式责任链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式 相似的设计模式 策略模式、状态模式 文章中的源码 点击 此处 查看。 额外资源 下面是23种设计模式的本站链接 单例模式","link":"/java-design-patterns/"},{"title":"设计模式-单例模式","text":"前言单例模式是23种设计模式中的一种，在开发过程中经常使用也是最简单易懂的一种设计模式。常用于初始化 线程池、缓存、注册表、日志等对象。 单例模式（Singleton Pattern）：确保一个类有且只有一个实例，并提供一个全局访问点。 1.私有化构造函数 2.唯一的公共出口 单例模式可分为懒汉式、饿汉式、静态内部类、枚举几种方式。 懒汉式懒汉式使用的是懒加载方式（lazy loading），是非线程安全的。不推荐使用 123456789101112131415161718192021222324public class Singleton1 { private static Singleton1 INSTANCE = null; /** * 1.私有化构造函数 */ private Singleton1() { } /** * 2.唯一的公共出口 * * @return Singleton1 */ public static Singleton1 getInstance() { // 判断是否存在实例 if (INSTANCE == null) { INSTANCE = new Singleton1(); } return INSTANCE; }} 变体1由于懒汉式是非线程安全的，所以可以通过 synchronized 使方法线程安全，但是效率比较低大多数情况下不需要进行同步。不推荐使用 123456789101112131415public class Singleton2 { private static Singleton2 INSTANCE = null; private Singleton2() { } public static synchronized Singleton2 getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton2(); } return INSTANCE; }} 变体2-双重校验锁变体1的升级版，通过使用 volatile 同步机制，既保证了效率，又保证了安全。俗称双重检查锁定。 12345678910111213141516171819202122public class Singleton5 { private volatile static Singleton5 INSTANCE = null; private Singleton5() { } public static Singleton5 getInstance() { // 第一次判断，如果这里为空，不进入抢锁阶段，直接返回实例 if (INSTANCE == null) { synchronized (Singleton5.class) { // 抢到锁之后再次判断是否为空 if (INSTANCE == null) { INSTANCE = new Singleton5(); } } } return INSTANCE; }} 饿汉式饿汉式是在类加载的时候就初始化了实例，不会出现线程同步的问题，是线程安全的。比较简单，使用较多 12345678910111213public class Singleton3 { private static Singleton3 INSTANCE = new Singleton3(); private Singleton3() { } public static Singleton3 getInstance() { return Singleton3.INSTANCE; }} 静态内部类静态内部类方式 Singleton4 类被装载了，但是没有初始化。只有调用 getInstance() 方法时才会被初始化，实现了懒加载方式。 1234567891011121314public class Singleton4 { private static class SingletonHolder { public static Singleton4 INSTANCE = new Singleton4(); } private Singleton4() { } public static Singleton4 getInstance() { return SingletonHolder.INSTANCE; }} 枚举枚举类实现单例模式是 effective java 作者极力推荐的单例实现模式。因为枚举类型是线程安全的，只会装载一次，并且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。推荐使用 1234567891011121314151617public class Singleton6 { private Singleton6() { } private static enum SingletonEnum { INSTANCE; private static Singleton6 instance = new Singleton6(); private static Singleton6 getInstance() { return instance; } }} 文章中的源码 点击 此处 查看。 小结除枚举类型的单例模式，其他类型的单例模式存在反射、序列化问题（私有化构造器可以受到反射攻击，序列化前后两个对象并不相等。）。","link":"/design-patterns-singleton/"},{"title":"","text":"JUCJ.U.C并发包，即java.util.concurrent包，是JDK的核心工具包，是JDK1.5之后，由 Doug Lea实现并引入。 整个java.util.concurrent包，按照功能可以大致划分如下： juc-locks 锁框架 juc-atomic 原子类框架 juc-sync 同步器框架 juc-collections 集合框架 juc-executors 执行器框架","link":"/"},{"title":"Java 多线程","text":"多线程能编写高效率的程序来达到充分利用 CPU 的目的。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 演变：一个指令 -&gt; 批处理 -&gt; 进程 -&gt; 线程 -&gt; 协程 进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。 程序是指令、数据及其组织形式的描述，进程是程序的实体。 一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核CPU来说，任意具体时刻都只有一个任务在占用CPU资源。 守护线程 线程进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。 线程让进程的内部并发成为了可能。 生命周期 新建状态 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态 当线程对象调用了 start() 方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。 运行状态 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态 如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 5（NORM_PRIORITY）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建方式 实现 Runable 接口 123456789101112131415161718192021222324252627public class RunnableDemo implements Runnable { /** * 3.运行状态 */ @Override public void run() { System.out.println(&quot;Implements runnable thread is run&quot;); System.out.println(&quot;当前线程组名字：&quot; +Thread.currentThread().getThreadGroup().getName()); System.out.println(&quot;Thread name:&quot; + Thread.currentThread().getName()); } public static void main(String[] args) { RunnableDemo runnableDemo = new RunnableDemo(); // 1.新建状态 Thread thread = new Thread(runnableDemo, &quot;Test&quot;); System.out.println(&quot;Thread name:&quot; + thread.getName()); // 2.就绪状态 thread.start(); System.out.println(&quot;执行main方法线程名字：&quot; + Thread.currentThread().getName()); }} 继承 Thread 类 1234567891011121314151617181920212223242526272829public class ThreadDemo extends Thread { public ThreadDemo(String name) { super(name); } /** * 3.运行状态 */ @Override public void run() { System.out.println(&quot;Extends Thread thread is run&quot;); System.out.println(&quot;当前线程组名字：&quot; +Thread.currentThread().getThreadGroup().getName()); System.out.println(&quot;Thread name:&quot; + Thread.currentThread().getName()); } public static void main(String[] args) { // 1.新建状态 ThreadDemo threadDemo = new ThreadDemo(&quot;Test&quot;); System.out.println(&quot;Thread name:&quot; + threadDemo.getName()); // 2.就绪状态 threadDemo.start(); System.out.println(&quot;执行main方法线程名字：&quot; + Thread.currentThread().getName()); }} 通过 Callable 和 Future 创建线程。 12345678910111213141516171819202122232425262728293031323334public class CallableDemo implements Callable&lt;Integer&gt; { /** * 3.运行状态 * * @return 返回值 * @throws Exception 异常 */ @Override public Integer call() throws Exception { int a = new Random(100).nextInt(1000); System.out.println(&quot;Implements runnable thread is run &quot; + a); System.out.println(&quot;当前线程组名字：&quot; +Thread.currentThread().getThreadGroup().getName()); System.out.println(&quot;Thread name:&quot; + Thread.currentThread().getName()); return a; } public static void main(String[] args) throws ExecutionException, InterruptedException { CallableDemo callableDemo = new CallableDemo(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callableDemo); // 1.新建状态 Thread thread = new Thread(futureTask); // 2.就绪状态 thread.start(); // 返回值 System.out.println(&quot;Result：&quot; + futureTask.get()); System.out.println(&quot;执行main方法线程名字：&quot; + Thread.currentThread().getName()); }} 协程Java 暂未正式发布协程。 多线程有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。 注： 上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！ 线程同步即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 同步方法 同步代码块 volatile 重入锁 局部变量 阻塞队列 原子变量 线程间通信锁与同步等待/通知机制信号量管道join() 方法sleep方法ThreadLocal类InheritableThreadLocal线程死锁线程控制：挂起、停止和恢复","link":"/java-multi-thread/"}],"tags":[{"name":"Centos","slug":"Centos","link":"/tags/Centos/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"flowable","slug":"flowable","link":"/tags/flowable/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客","slug":"blog","link":"/tags/blog/"},{"name":"Jetbrains","slug":"Jetbrains","link":"/tags/Jetbrains/"},{"name":"crack","slug":"crack","link":"/tags/crack/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"热部署","slug":"热部署","link":"/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SPI","slug":"SPI","link":"/tags/SPI/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"算法","slug":"algorithm","link":"/tags/algorithm/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"工具","slug":"tool","link":"/tags/tool/"},{"name":"Arthas","slug":"Arthas","link":"/tags/Arthas/"},{"name":"绘图","slug":"绘图","link":"/tags/%E7%BB%98%E5%9B%BE/"},{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"SFTP","slug":"SFTP","link":"/tags/SFTP/"},{"name":"NVM","slug":"NVM","link":"/tags/NVM/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"Centos","slug":"Centos","link":"/categories/Centos/"},{"name":"flowable","slug":"flowable","link":"/categories/flowable/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Jetbrains","slug":"Jetbrains","link":"/categories/Jetbrains/"},{"name":"IDEA","slug":"IDEA","link":"/categories/IDEA/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"力扣","slug":"力扣","link":"/categories/%E5%8A%9B%E6%89%A3/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"工具","slug":"tool","link":"/categories/tool/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"多线程","slug":"Java/多线程","link":"/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}